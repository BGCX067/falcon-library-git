little_endian et big_endian non vérifier
number.hpp pas finalisée
voir les TODO et NOTE de endian.hpp

fonction de construction par lot voir bits/stl_uninitialized.h et bits/stl_construct.h (+implementation qui ne fait pas de destruction en passant par exemple un no_garbage_collector_t ou en indiquand dans le nom uninitialized_without_garbage_collector qui retourne un objet avec l'exceptions ou non et l'iterator de fin). fichier à mettre dans memory. Trouver un autre nom que garbage_collector.

rendre operator.hpp un peu compatible c++89

fonction get<std::size_t, std::initilizer_list>(std::initilizer_list) (fichier get_initializer_list ?). Grace a ça, std::initilizer_list doit fonctionner avec tuple_call<>().

modifier CPP0X_PROTO et CPP0X_DELEGATE_FUNCTION pour que le second argument soit une expression. Donc CPP0X_PROTO(f(char), (int)), CPP0X_DELEGATE_FUNCTION(f(char c), (c+8)). Faire un CPP0X_PROTO_EXPR qui fait comme CPP0X_DELEGATE_FUNCTION mais avec juste le prototype.

Essayer d'enlever un maximum de __VA_ARGS__

faire un allocator (compatible C++89) qui fonctionne comme une pile et ne delete jamais (boost::pool_allocator ?)

objet optimiser pour la conversion de chiffre en chaine numeric_string<TypeInt, CharT, CharTraits>. Notamment pour ce qui est de l'incrementation de chaine (et l'incrementation répercuter en general (ex: unite puis dizaine, etc)). pouvoir utilisé des char* ou std::string. Le CharTraits fait l'affaire ? faire un typedef pour le c et wchar en string ou non. (cnumeric_string, cnumeric_wstring, numeric_string, numeric_wstring). Le type char* peut fonctionne avec unique_ptr. Laisser à l'utilisateur choisir le container de stockage (on boucle dessus avec infinite_iterator pour écrire les chiffres)

iota(begin(), end(), first_value): le faire avec iota(container, first_value)

flag.hpp: doit possèder un constructeur avec avec initializer_list.
flag<>::operator[n] : bit_flag<> ? bit_wrapper<_T>{_T*} ?

optimiser recursive_iterator (et l'algo de recurtion) pour les tableaux. En partant du principe que a[x][y] = a[x*y] ne faire qu'une boucle

faire un algorithmfwd.hpp pour bien nommer les champs

fairer des macros comme BOOST pour la gestion des flux: FALCON_FLUX(ostream) -> std::basic_ostream<typename _CharT, typename _CharTraits> avec des sous macro pour le "paramètrage"

optimisation de taille des enum class: enum class E : typename std::conditional<l.size() == 2, bool, int>::type {…}; (minimal_int<>::type ?)

Mettre constexpr pour les classe d'operateur et enum/operator

ajouter le calcul (A+(B-1))/B qui permet de calculer le nombre requis de B pour mettre A (equivalent à A/B+(A%B?1:0) qui est le plus rapide ? le compilateur gènére le même code ? optimisation ?). quotient partiel.

faire un iterator qui itère sur plusieur -à la manière de multiple_iterator- mais ne fait les comparaisons que sur le premier (le merger avec multiple_iterator via des type_traits ?) (le nommer group_iterator ?).

refaire les fonctions de bits/ostream_insert.h ? deja mi dans ostream/ostream_insert.hpp ? (toutes ?)

finaliser les tests pour enumeration.cpp. Mettre a jour la doc de enum/enumerator.hpp et y extraire NOTE et TODO

revoir btree et btree_base et réactiver les tests

dans container_wrapper.hpp, ajouter des fonctions comme reverse_container, const_container, etc.

faire des traits char_traits qui transforme tout en majuscule, en minuscule et élimine les accents. Faire un string qui fait des comparaisons insensibles à la case. Quel char_traits existe-il dans boost ?

ne pas oublier le suport de char16_t et char32_t

le hash dans basic_cstring a externaliser dans un hash.hpp. Faire un hash_byte() comme la std.

mettre tous les operator()(...) des foncteurs en const (si cela est possible).

basic_string_repetition<_String>{_String, size_t} ? (os << string_repetition('a', 4) -> "aaaa"). faire std::to_string()

ostream::repetition(_Obj, size_t) et ostream::repetition(_Obj, size_t, _CharT separator) ; avec _CharT = _Obj::char_type. Idem pour les ostream

si on active les exceptions des flux, comment ce comporte les fonctions lié (ignore, ignore_all, etc) ? Le state est bien setter à badbit et non égal à good.

un foncteur qui permet de répartir les valeurs de plusieurs iterateurs. foreah(first, last, ???(it1, it2, it3)) -> ???::f(*it, *it1, *it2, *it3); ++it1,++it2,++it3.

ajouter les typedef result_type, argument_type, first_argument_type et second_argument_type -quand possible- dans les classes de operators.hpp. Faire un not1 et not2 comme la std.

structure englopant un type et pour chaque operateur suceptible de changer le type (pour les type scalaire < int) fait un static_cast. (force_type<_T> ? force_type_wrapper<> ? force_scalar<> ? integral_wrapper<> ?). Cas particulier pour l'incrementation et decrementation sur enum.
Permet ainsi de s'affranchir des enum_* en passant par les foncteurs sur operateurs: enum_plus<enum_t> -> plus<integral_wrapper<enum_t>>, enum_increment<enum_t> -> increment<integral_wrapper<enum_t&>>
ajouter le keyword enum pour enum/operators.hpp ou étendre une classe au nom plus générique qui fait un cast pour les opérations arithmétique ou binaire (plus_conversion, etc ?). La classe generique heriter des operateurs de la façon décrit au-dessus.

amélioré algorithm.hpp en "optimisant" les algos quand possible (nottament quand directement utilisé avec un container). std::remove(s.begin(), s.end(), ',') copie inutile de caractères jusqu'à la première occurence trouvé. falcon::remove(s, ',') cherche la première occurence (std::find) puis utilise std::remove.

singleton<_T> qui utilise static_new. Peut-être un singleton_id<_T, _Id>. Voir aussi call_once

container trier de façon static. version map et set et unordered. Faire un static_check<obj, compare, predicate>() ou un truc du genre. Pour permettre de vérifier des conditions à la compilation.

les lambdas toujours par reference ou il parfois utiliser std::ref ? Pas le cas pour while_loop et co...

faire un make_parameter_adapter() et un make_tuple_applier().

temporary_tuple_cat (tuple concatener par reference ?)

tuple_organizer<_Tag, bool no_tuple_parameter_is_tuple = true> pour faire une agglomération de tuple et filtrer les éléments non voulut. tuple_organizer<_Functor, _Tag> avec _Tag parameter-tag, parameter_index<> ou wrapper avec organizer_for_each_tag (ex organizer_for_each_tag<_Tag>) qui va s'appliquer indépendament sur chaque tuple. Passer par un traits pour faire appliquer ces tags: organizer_tag_to_parameter_index<_Tag, _Tuples>::type

les tuple_* doivent fonctionner avec std::pair<>, faire des tests

unary_compose et binary_compose doivent pouvoir deviné le type des fonctions

faire en sorte que mulary_compose passe par héritage au lieu de tuple. Le bool passé en template ne doit pas existé autrement qu'en interne. renommer en *_base et passer par un alias ?
mulary_compose doit hériter et compose retourner unary_compose ou binary_compose quand cela est possible.

unary_compose, binary_compose et mulary_compose supporte falcon::ignore quand on les construits

faire un function_compose<...> (+ fonction composef()) comme mulary_compose mais prend un nombre de paramètre allant de 0 à infinit.

dans enumerator faire une allocation de la chaîne en tant que expression constante (déjà fait ?)

tester les compose() avec les distributions (voir random_device ? (exemple dans cppreference.com avec les distributions))

les compose() devrais pouvoir fonctionenr avec les références (pas le cas actuellement). Fonctionne avec std::ref() sans perte de perf (même binaire) ?

strong_reference_wrapper: faire des tests

une sorte de unary_compose mais sans arguments -> f(g()). (ancien delegate_result -> delegate_wrapper ?). Il y en a pas déjà une qui prend plusieurs foncteurs ?

enlever les doubles underscore car reservé. Idem pour les underscores suivit de majuscule dans l'espace globale.

Vérifier les types tag dans les iterateurs.
Ajouter dans les iterators les fonctions pour acceder au fonctor lorsque ceux-ci en utilisent (fn() ?).

ostream/join.hpp est devenu trop complexe, simplifier ! Idem pour istream/ignore.hpp ?

algorithm.hpp : ne prend pas en compte les containers constant…

un iterateur qui execute une fonction apres avoir atteint une valeur (autre iterateur ou compteur (2 classes ?)). Permet par exemple de boucler en une fois sur une zone d'un rectangle.
padding_iterator: pour par exemple iterer sur un sous retangle.
un iterator qui prend 2 iterators et quand arrive au bout utilise une/deux fonction(s) de modification pour les 2 iterators. Est un recursive_iterator ? En tout cas padding_iterator pourrait en heriter.

tuple_get_accessor → get_idx_accessor ? getidx_accessor ? get_index_accessor ?

flag.hpp: pb avec le decalage de bit de flag. flag.cpp: god for gcc-4.7, fail with gcc-4.6…

enlever pseudo_iterator et faire [in|out]put_iterator_base

late_delegation<_FunctorTemplate, _FunctorAllocator = always<> > -> operator(…) { return _FunctorAllocator(…) } ; _FunctorAllocator -> return _ClassTemplate<_T>()

utiliser __CHAR_BIT__ dans bit/bit_swap.hpp et bit/detail/bit_swap.hpp (en fait les fonction change selon le nombre de bit…)

synchronous_iterator qui permet d'avancer 2 itérateurs en même temps. 2 trait (1 par itérateurs). Faire un double_traits qui combine les 2. base() retourne une pair et le trait contient le getter. Posibilité de passé par un adaptateur qui retourne une tuple ou possède un get_base<N>(). Sera utilisé par delegate_comparison_iterator. Basé sur synchronizer<>.

l'actuel delegate_comparison_iterator est en fait un multiple_iterator avec un seul iterateur de comparaison (utilise keep_parameter_index). Le changer pour qu'il fonctionne comme indirect_iterator mais uniquement pour la comparaison.

ajouter PP dans les macros de preprocessor (FALCON_CAT ⇒ FALCON_PP_CAT) qui sera remplacé par BOOST_PP_CAT

tuple_*: ignorer les valeurs de type std::ignore_t. Les fonctions retournant void, voient leur type changer en std::ignore_t.

completer les operateurs de range_modifier et faire un for_each() et un invoke(). enlever unary() et binary() ? Passer par operator() ? uniquement par invoke() ?

literal/utility.hpp: support de la convertion de flottant et faire le support de l'hexadecimal et octal pour les entegrals et l'hexadecimal pour les flottants (voir pdf plus bas pour les suffix).

renommer le dossier c++0x en c++11 ?
modifier les noms des macro CPP0X_* et CPP_* en FALCON_* (et FALCON_CXX11_ ?)
renommer CPP_USE_CONSTEXPR en FALCON_CONSEXPR_OR_CONST
#define FALCON_STATIC_CONSTEXPR static FALCON_CONSEXPR_OR_CONST
utilisé les macros prédéfinit dans boost et ne plus utilisé __GXX_EXPERIMENTAL_CXX0X__
www.boost.org/doc/libs/1_49_0/libs/config/doc/html/boost_config/boost_macro_reference.html

Utiliser d'avantage FALCON_BOOST_OR_STD_NAMESPACE et FALCON_BOOST_OR_STD_TRAITS (c++/boost_or_std.hpp)

note/*.hpp: les node peuvent fonctionne de facon transparente avec des std::unique_ptr ?

implémenter la proposition de suffix dans la nouvelle norme: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3402.pdf
ne pas oublier de prendre en compte les unité (non mis dans la norme) avec les abréviation udl ou iso

falcon::algorithm::filter(container, predicate, cp)

optimal tuple : http://flamingdangerzone.com/cxx11/2012/12/02/optimal-tuple-ii.html










